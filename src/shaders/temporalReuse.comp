#version 450

/*#define COMPARE_DEPTH*/

#include "include/reservoir.glsl"
#include "include/restirUtils.glsl"

layout (local_size_x = TEMPORAL_REUSE_GROUP_SIZE_X, local_size_y = TEMPORAL_REUSE_GROUP_SIZE_Y, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms {
	RestirUniforms uniforms;
};

layout (binding = 1) uniform sampler2D uniWorldPosition;
layout (binding = 2) uniform sampler2D uniAlbedo;
layout (binding = 3) uniform sampler2D uniNormal;
layout (binding = 4) uniform sampler2D uniMaterialProperties;
layout (binding = 5) uniform sampler2D uniPrevFrameWorldPosition;
layout (binding = 6) uniform sampler2D uniPrevFrameAlbedo;
layout (binding = 7) uniform sampler2D uniPrevFrameNormal;
layout (binding = 8) uniform sampler2D uniPrevDepth;

layout (binding = 9) buffer PrevFrameReservoirs {
	Reservoir prevFrameReservoirs[];
};
layout (binding = 10) buffer Reservoirs {
	Reservoir reservoirs[];
};

void main() {
	uvec2 pixelCoord = gl_GlobalInvocationID.xy;
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

	vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;

	vec4 prevFramePos = uniforms.prevFrameProjectionViewMatrix * vec4(worldPos, 1.0f);
	prevFramePos.xyz /= prevFramePos.w;
	prevFramePos.xy = (prevFramePos.xy + 1.0f) * 0.5f * vec2(uniforms.screenSize);
	if (
		any(lessThan(prevFramePos.xy, vec2(0.0f))) ||
		any(greaterThan(prevFramePos.xy, vec2(uniforms.screenSize)))
	) {
		return;
	}

	ivec2 prevFrag = ivec2(prevFramePos.xy);

#ifdef COMPARE_DEPTH
	float depthDiff = prevFramePos.z - texelFetch(uniPrevDepth, prevFrag, 0).x;
	if (depthDiff > 0.001f * prevFramePos.z) {
		return;
	}
#else
	// highest quality results can be obtained by directly comparing the world positions
	// the performance impact of this is unclear
	vec3 positionDiff = worldPos - texelFetch(uniPrevFrameWorldPosition, prevFrag, 0).xyz;
	if (dot(positionDiff, positionDiff) > 0.01f) {
		return;
	}
#endif

	vec3 albedo = texelFetch(uniAlbedo, ivec2(pixelCoord), 0).rgb;
	vec3 albedoDiff = albedo - texelFetch(uniPrevFrameAlbedo, prevFrag, 0).rgb;
	if (dot(albedoDiff, albedoDiff) > 0.01f) {
		return;
	}

	vec3 normal = texelFetch(uniNormal, ivec2(pixelCoord), 0).xyz;
	float normalDot = dot(normal, texelFetch(uniPrevFrameNormal, prevFrag, 0).xyz);
	if (normalDot < 0.5f) {
		return;
	}

	uint reservoirIndex = pixelCoord.y * uniforms.screenSize.x + pixelCoord.x;
	Rand rand = seedRand(uniforms.frame * 17, reservoirIndex);
	Reservoir res = reservoirs[reservoirIndex];
	Reservoir prevRes = prevFrameReservoirs[prevFrag.y * uniforms.screenSize.x + prevFrag.x];

	// clamp the number of samples
	prevRes.numStreamSamples = min(prevRes.numStreamSamples, 20 * res.numStreamSamples);

	vec2 metallicRoughness = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;

	vec4 pHat[RESERVOIR_SIZE];
	for (int i = 0; i < RESERVOIR_SIZE; ++i) {
		pHat[i].rgb = evaluatePHat(
			worldPos, prevRes.samples[i].position.xyz, uniforms.cameraPos.xyz,
			normal, albedo, prevRes.samples[i].emission.rgb, metallicRoughness.x, metallicRoughness.y
		);
		pHat[i].w = luminance(pHat[i].r, pHat[i].g, pHat[i].b);
	}

	combineReservoirs(res, prevRes, pHat, rand);

	reservoirs[reservoirIndex] = res;
}
