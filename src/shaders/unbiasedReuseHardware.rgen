#version 460 core
#extension GL_EXT_ray_tracing : enable

#include "include/disneyBRDF.glsl"
#include "include/structs/lightingPassStructs.glsl"
#include "include/reservoir.glsl"

layout(location = 0) rayPayloadEXT bool isShadowed;

layout(binding = 0) uniform accelerationStructureEXT acc;

layout (binding = 1) uniform sampler2D uniWorldPosition;

layout (binding = 2) buffer Reservoirs {
    Reservoir reservoirs[];
};

layout (binding = 3) uniform Restiruniforms {
	RestirUniforms restirUniforms;
};

float sceneDepthToWorldDepth(float depth, float near, float far) {
	return near * far / (far + depth * (near - far));
}

vec3 fragCoordDepthToViewPos(vec2 uv, float worldDepth, float tanHalfFovY, float aspectRatio) {
	uv = uv * 2.0f - 1.0f; // [0, 1] to [-1, 1]
	uv.x *= aspectRatio;
	return vec3(uv * worldDepth * tanHalfFovY, worldDepth);
}

void main() {
    uvec2 pixelCoord = gl_LaunchIDEXT.xy;
	if (any(greaterThanEqual(pixelCoord, restirUniforms.screenSize))) {
		return;
	}

    vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;
	uint reservoirIndex = pixelCoord.y * restirUniforms.screenSize.x + pixelCoord.x;

    Reservoir res = reservoirs[reservoirIndex];

    uint rayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    float tMin     = 0.001;

    for(int i = 0; i < RESERVOIR_SIZE; i++)
    {
        isShadowed = true;
       
        vec3 curLightPos = vec3(res.samples[i].position_emissionLum.xyz);
        vec3 curDirection = vec3(curLightPos) - worldPos;
        float curTMax = length(curDirection);
        curDirection = normalize(curDirection);
        vec3 origin    = worldPos + 0.001 * curDirection;

        traceRayEXT(acc,     // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            origin.xyz,     // ray origin
            tMin,           // ray min range
            curDirection.xyz,  // ray direction
            curTMax - 0.002,           // ray max range
            0               // payload (location = 0)
        );

        if(isShadowed)
        {
            res.samples[i].w = 0.0f;
            res.samples[i].sumWeights = 0.0f;
        }
    } 
    reservoirs[reservoirIndex] = res;
}
