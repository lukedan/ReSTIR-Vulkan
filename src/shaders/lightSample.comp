#version 450

#include "include/restirUtils.glsl"
#include "include/reservoir.glsl"
#include "include/structs/light.glsl"
#include "include/RIS.glsl"

layout (local_size_x = LIGHT_SAMPLE_GROUP_SIZE_X, local_size_y = LIGHT_SAMPLE_GROUP_SIZE_Y, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms {
	RestirUniforms uniforms;
};

layout (binding = 1) uniform sampler2D uniAlbedo;
layout (binding = 2) uniform sampler2D uniNormal;
layout (binding = 3) uniform sampler2D uniMaterialProperties;
layout (binding = 4) uniform sampler2D uniWorldPosition;

layout (binding = 5) buffer Reservoirs {
	Reservoir reservoirs[];
};
layout (binding = 6) buffer PointLights {
	int count;
	pointLight lights[];
} pointLights;
layout (binding = 7) buffer TriangleLights {
	int count;
	triLight lights[];
} triangleLights;
layout (binding = 8) buffer AliasTable{
	int count;
	aliasTableColumn aliasCol[];
} aliasTable;

int aliasTableSample(float r1, float r2){
	int selected_column = int(aliasTable.count * r1);
	int selected_sample = -1;
	if(aliasTable.aliasCol[selected_column].prab > r2){
		selected_sample = selected_column;
	}else{
		selected_sample = aliasTable.aliasCol[selected_column].alias;
	}
	return selected_sample;
}

void main() {
	uvec2 pixelCoord = gl_GlobalInvocationID.xy;
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

	vec3 albedo = texelFetch(uniAlbedo, ivec2(pixelCoord), 0).xyz;
	vec3 normal = texelFetch(uniNormal, ivec2(pixelCoord), 0).xyz;
	vec2 roughnessMetallic = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;
	vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;

	// RIS -- TODO: w needs to adopt triangle lights.
	lightSample xSet[32];
	float wSet[32];
	float wSum = 0.f;
	for (int i = 0; i < 32; ++i) {
		Rand rand_light_sample1;
		rand_light_sample1.context = uniforms.frame + i * 17 + pixelCoord.y * 99997913 + pixelCoord.x * 29;
		randUint16(rand_light_sample1);
		Rand rand_light_sample2;
		rand_light_sample2.context = uniforms.frame * 3 + i * 5 + pixelCoord.y * 11 + pixelCoord.x * 10002871;
		randUint16(rand_light_sample2);
		
		int selected_idx = aliasTableSample(randFloat(rand_light_sample1), randFloat(rand_light_sample2));

		pointLight light = pointLights.lights[selected_idx];

		vec3 pHat = evaluatePHat(
			worldPos, light.pos.xyz, uniforms.cameraPos.xyz, normal,
			albedo, light.color.xyz, roughnessMetallic.x, roughnessMetallic.y
		);
		float pHatLum = luminance(pHat.r, pHat.g, pHat.b);

		xSet[i].pos = light.pos.xyz;
		xSet[i].pHat = pHat;
		xSet[i].pHatLum = pHatLum;
		xSet[i].p = aliasTable.aliasCol[selected_idx].oriPrab;
		wSet[i] = pHatLum / aliasTable.aliasCol[selected_idx].oriPrab;
		wSum += wSet[i];
	}
	// Select from candidate
	Rand rand_sele_cand;
	rand_sele_cand.context = uniforms.frame * 5 + pixelCoord.y * 1543 + pixelCoord.x * 12043;
	randUint16(rand_sele_cand);
	float cumulated_weight = 0.0;
	float rand_cand_float = randFloat(rand_sele_cand);
	int z = 31;
	for(int i = 0; i < 32; ++i){
		cumulated_weight += wSet[i];
		if(rand_cand_float < (cumulated_weight / wSum)){
			z = i;
			break;
		}
	}
	// Give the sample to reservior
	Reservoir res = newReservoir();
	Rand rand;
	rand.context = uniforms.frame * 13 + pixelCoord.y * 10007 + pixelCoord.x * 13;
	randUint16(rand);

	lightSample y = xSet[z];
	addSampleToReservoir(res, y.pos, vec4(y.pHat, y.pHatLum), y.p, rand);

	uint reservoirIndex = pixelCoord.y * uniforms.screenSize.x + pixelCoord.x;
	reservoirs[reservoirIndex] = res;
}
