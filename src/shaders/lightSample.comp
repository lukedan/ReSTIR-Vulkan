#version 450

#include "include/restirUtils.glsl"
#include "include/reservoir.glsl"
#include "include/structs/light.glsl"
#include "include/RIS.glsl"

layout (local_size_x = LIGHT_SAMPLE_GROUP_SIZE_X, local_size_y = LIGHT_SAMPLE_GROUP_SIZE_Y, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms {
	RestirUniforms uniforms;
};

layout (binding = 1) uniform sampler2D uniAlbedo;
layout (binding = 2) uniform sampler2D uniNormal;
layout (binding = 3) uniform sampler2D uniMaterialProperties;
layout (binding = 4) uniform sampler2D uniWorldPosition;

layout (binding = 5) buffer Reservoirs {
	Reservoir reservoirs[];
};
layout (binding = 6) buffer PointLights {
	int count;
	pointLight lights[];
} pointLights;
layout (binding = 7) buffer TriangleLights {
	int count;
	triLight lights[];
} triangleLights;

layout (binding = 8) buffer AliasTable{
	int count;
	aliasTableColumn aliasCol[];
} aliasTable;

// https://math.stackexchange.com/questions/18686/uniform-random-point-in-triangle
vec3 pickPointOnTriangle(float r1, float r2, vec3 p1, vec3 p2, vec3 p3) {
    float sqrt_r1 = sqrt(r1);
    return (1.0 - sqrt_r1) * p1 + (sqrt_r1 * (1.0 - r2)) * p2 + (r2 * sqrt_r1) * p3;
}

float DistanceSquared(vec3 a, vec3 b) {
    float len = length(a - b);
    return len * len;
}

// http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html#sec:sampling-lights
float triLightPDF(triLight sampledTriLight, vec3 wi, vec3 sampledTriLightPos, vec3 refPoint) {
    vec3 lightNormal = normalize(cross(sampledTriLight.p2.xyz - sampledTriLight.p1.xyz, sampledTriLight.p3.xyz - sampledTriLight.p1.xyz));
    return DistanceSquared(refPoint, sampledTriLightPos) / (abs(dot(lightNormal, wi)) * sampledTriLight.area);
}

int aliasTableSample(float r1, float r2){
	int selected_column = int(aliasTable.count * r1);
	int selected_sample = -1;
	if(aliasTable.aliasCol[selected_column].prab > r2){
		selected_sample = selected_column;
	}else{
		selected_sample = aliasTable.aliasCol[selected_column].alias;
	}
	return selected_sample;
}

void main() {
	uvec2 pixelCoord = gl_GlobalInvocationID.xy;
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

	vec3 albedo = texelFetch(uniAlbedo, ivec2(pixelCoord), 0).xyz;
	vec3 normal = texelFetch(uniNormal, ivec2(pixelCoord), 0).xyz;
	vec2 roughnessMetallic = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;
	vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;

	/* Streaming RIS using WRS -- TODO: w needs to adopt triangle lights. */
	Reservoir res = newReservoir();
	Rand rand;
	rand.context = uniforms.frame + pixelCoord.y * 10007 + pixelCoord.x * 13;
	randUint16(rand);
	for (int i = 0; i < 32; ++i) {			
		int selected_idx = aliasTableSample(randFloat(rand), randFloat(rand));

		vec3 lightSamplePos;
		vec3 lightSampleColor;
		if(pointLights.count != 0){
			pointLight light = pointLights.lights[selected_idx];
			lightSamplePos = light.pos.xyz;
			lightSampleColor = light.color.xyz;
		}else{
			triLight light = triangleLights.lights[selected_idx];
			lightSamplePos = pickPointOnTriangle(randFloat(rand), randFloat(rand), light.p1.xyz, light.p2.xyz, light.p3.xyz);
			lightSampleColor = light.emissiveFactor.xyz;
		}
		
		vec3 pHat = evaluatePHat(
			worldPos, lightSamplePos, uniforms.cameraPos.xyz, normal,
			albedo, lightSampleColor, roughnessMetallic.x, roughnessMetallic.y
		);
		float pHatLum = luminance(pHat.r, pHat.g, pHat.b);

		addSampleToReservoir(res, lightSamplePos, vec4(pHat, pHatLum), aliasTable.aliasCol[selected_idx].oriPrab, rand);
	}
	
	uint reservoirIndex = pixelCoord.y * uniforms.screenSize.x + pixelCoord.x;
	reservoirs[reservoirIndex] = res;
}
