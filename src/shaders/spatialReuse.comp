#version 450

#include "include/reservoir.glsl"
#include "include/restirUtils.glsl"

layout (local_size_x = SW_VISIBILITY_TEST_GROUP_SIZE_X, local_size_y = SW_VISIBILITY_TEST_GROUP_SIZE_Y, local_size_z = 1) in;

layout (binding = 0) uniform Uniforms {
	RestirUniforms uniforms;
};

layout (binding = 1) uniform sampler2D uniWorldPosition;
layout (binding = 2) uniform sampler2D uniAlbedo;
layout (binding = 3) uniform sampler2D uniNormal;
layout (binding = 4) uniform sampler2D uniMaterialProperties;

layout (binding = 5) buffer Reservoirs {
	Reservoir reservoirs[];
};

layout (binding = 6) buffer Resultreservoirs
{
	Reservoir resultReservoirs[];
};

#define RAND_NEIGHBOURS 3
#define RAND_RADIUS 30.0

void main() {
	uvec2 pixelCoord = gl_GlobalInvocationID.xy;
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

	vec3 albedo = texelFetch(uniAlbedo, ivec2(pixelCoord), 0).xyz;
	vec3 normal = texelFetch(uniNormal, ivec2(pixelCoord), 0).xyz;
	vec2 roughnessMetallic = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;
	vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;

	uint reservoirIndex = pixelCoord.y * uniforms.screenSize.x + pixelCoord.x;
	Reservoir res = reservoirs[reservoirIndex];

	Rand rand = seedRand(uniforms.frame * 31, pixelCoord.y * 10007 + pixelCoord.x);
	for(int i = 0; i < RAND_NEIGHBOURS; i++)
	{
		ivec2 randNeighbor = ivec2(0, 0);
		
		float angle = randFloat(rand) * 2.0 * M_PI;
		float radius = randFloat(rand) * RAND_RADIUS;

		ivec2 randNeighborOffset = ivec2(floor(cos(angle) * radius), floor(sin(angle) * radius));
		randNeighbor.x = clamp(int(pixelCoord.x) + randNeighborOffset.x, 0, int(uniforms.screenSize.x) - 1);
		randNeighbor.y = clamp(int(pixelCoord.y) + randNeighborOffset.y, 0, int(uniforms.screenSize.y) - 1);

		uint randIndex = randNeighbor.y * uniforms.screenSize.x + randNeighbor.x;
		
		// Discard over biased neighbors
		vec3 neighborNor = texelFetch(uniNormal, ivec2(randNeighbor), 0).xyz;
		vec3 neighborPos = texelFetch(uniNormal, ivec2(randNeighbor), 0).xyz;

		if(abs(neighborPos.z - worldPos.z) > 0.1 * abs(worldPos.z) || abs(dot(neighborNor, normal)) > cos(0.7 * M_PI))
			continue;

		Reservoir randRes = reservoirs[randIndex];
		vec4 newPHats[RESERVOIR_SIZE];

		for(int j = 0; j < RESERVOIR_SIZE; j++)
		{
			vec3 newPHat = evaluatePHat(
			worldPos, randRes.samples[j].position.xyz, uniforms.cameraPos.xyz, normal,
			albedo, randRes.samples[j].emission.xyz, roughnessMetallic.x, roughnessMetallic.y);
			float pHatLum = luminance(newPHat.r, newPHat.g, newPHat.b);
			vec4 newPHat4 = vec4(newPHat, pHatLum);
			newPHats[j] = newPHat4;
		}		
		combineReservoirs(res, randRes, newPHats, rand);
	}
	resultReservoirs[reservoirIndex] = res;
}