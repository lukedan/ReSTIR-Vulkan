#version 460 core
#extension GL_EXT_ray_tracing : enable

#include "include/structs/lightingPassStructs.glsl"
#include "include/reservoir.glsl"
#include "include/restirUtils.glsl"
#include "include/structs/light.glsl"


layout(location = 0) rayPayloadEXT bool isShadowed;

layout(binding = 0, set = 0) uniform accelerationStructureEXT acc;

layout (binding = 1, set = 0) uniform sampler2D uniWorldPosition;

layout (binding = 2, set = 0) buffer Reservoirs {
    Reservoir reservoirs[];
};

layout (binding = 3, set = 0) uniform Restiruniforms {
	RestirUniforms uniforms;
};

layout (binding = 0, set = 1) uniform sampler2D uniAlbedo;
layout (binding = 1, set = 1) uniform sampler2D uniNormal;
layout (binding = 2, set = 1) uniform sampler2D uniMaterialProperties;

layout (binding = 3, set = 1) buffer PointLights {
	int count;
	pointLight lights[];
} pointLights;

layout (binding = 4, set = 1) buffer TriangleLights {
	int count;
	triLight lights[];
} triangleLights;

layout (binding = 5, set = 1) buffer AliasTable{
	int count;
	aliasTableColumn aliasCol[];
} aliasTable;

layout (binding = 0, set = 2) uniform sampler2D uniPrevFrameWorldPosition;
layout (binding = 1, set = 2) uniform sampler2D uniPrevFrameAlbedo;
layout (binding = 2, set = 2) uniform sampler2D uniPrevFrameNormal;
layout (binding = 3, set = 2) uniform sampler2D uniPrevDepth;

layout (binding = 4, set = 2) buffer PrevFrameReservoirs {
	Reservoir prevFrameReservoirs[];
};

vec3 pickPointOnTriangle(float r1, float r2, vec3 p1, vec3 p2, vec3 p3) {
    float sqrt_r1 = sqrt(r1);
    return (1.0 - sqrt_r1) * p1 + (sqrt_r1 * (1.0 - r2)) * p2 + (r2 * sqrt_r1) * p3;
}

int aliasTableSample(float r1, float r2){
	int selected_column = int(aliasTable.count * r1);
	int selected_sample = -1;
	if(aliasTable.aliasCol[selected_column].prob > r2){
		selected_sample = selected_column;
	}else{
		selected_sample = aliasTable.aliasCol[selected_column].alias;
	}
	return selected_sample;
}


float sceneDepthToWorldDepth(float depth, float near, float far) {
	return near * far / (far + depth * (near - far));
}

vec3 fragCoordDepthToViewPos(vec2 uv, float worldDepth, float tanHalfFovY, float aspectRatio) {
	uv = uv * 2.0f - 1.0f; // [0, 1] to [-1, 1]
	uv.x *= aspectRatio;
	return vec3(uv * worldDepth * tanHalfFovY, worldDepth);
}

void main() {
    // Light Sampling
    uvec2 pixelCoord = gl_LaunchIDEXT.xy;
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

	vec3 albedo = texelFetch(uniAlbedo, ivec2(pixelCoord), 0).xyz;
	vec3 normal = texelFetch(uniNormal, ivec2(pixelCoord), 0).xyz;
	vec2 roughnessMetallic = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;
	vec3 worldPos = texelFetch(uniWorldPosition, ivec2(pixelCoord), 0).xyz;

	Reservoir res = newReservoir();
	Rand rand = seedRand(uniforms.frame * 31, pixelCoord.y * 10007 + pixelCoord.x);
	for (int i = 0; i < uniforms.initialLightSampleCount; ++i) {			
		int selected_idx = aliasTableSample(randFloat(rand), randFloat(rand));

		vec3 lightSamplePos;
		vec3 lightSampleColor;
		float sampleProb;
		if(pointLights.count != 0){
			pointLight light = pointLights.lights[selected_idx];
			lightSamplePos = light.pos.xyz;
			lightSampleColor = light.color.xyz;
			sampleProb = aliasTable.aliasCol[selected_idx].oriProb;
		}else{
			triLight light = triangleLights.lights[selected_idx];
			lightSamplePos = pickPointOnTriangle(randFloat(rand), randFloat(rand), light.p1.xyz, light.p2.xyz, light.p3.xyz);
			lightSampleColor = light.emissiveFactor.xyz;

			vec3 wi = normalize(worldPos - lightSamplePos);
			vec3 normal = light.normalArea.xyz;
			sampleProb = aliasTable.aliasCol[selected_idx].oriProb / (abs(dot(wi, normal)) * light.normalArea.w);
		}
		
		vec3 pHat = evaluatePHat(
			worldPos, lightSamplePos, uniforms.cameraPos.xyz, normal,
			albedo, lightSampleColor, roughnessMetallic.x, roughnessMetallic.y
		);
		float pHatLum = luminance(pHat.r, pHat.g, pHat.b);

		addSampleToReservoir(res, lightSamplePos, lightSampleColor, vec4(pHat, pHatLum), sampleProb, rand);
	}
	
	uint reservoirIndex = pixelCoord.y * uniforms.screenSize.x + pixelCoord.x;
	
    // Visibility Reuse
	if (any(greaterThanEqual(pixelCoord, uniforms.screenSize))) {
		return;
	}

    uint rayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    float tMin     = 0.001;

    for(int i = 0; i < RESERVOIR_SIZE; i++)
    {
        isShadowed = true;
       
        vec3 curLightPos = vec3(res.samples[i].position);
        vec3 curDirection = vec3(curLightPos) - worldPos;
        float curTMax = length(curDirection);
        curDirection = normalize(curDirection);
         vec3 origin    = worldPos + 0.001 * curDirection;

        traceRayEXT(acc,     // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            0,              // missIndex
            origin.xyz,     // ray origin
            tMin,           // ray min range
            curDirection.xyz,  // ray direction
            curTMax - 0.002,           // ray max range
            0               // payload (location = 0)
        );

        if(isShadowed)
        {
            res.samples[i].w = 0.0f;
            res.samples[i].sumWeights = 0.0f;
        }
    } 
    //reservoirs[reservoirIndex] = res;
	vec4 prevFramePos = uniforms.prevFrameProjectionViewMatrix * vec4(worldPos, 1.0f);
	prevFramePos.xyz /= prevFramePos.w;
	prevFramePos.xy = (prevFramePos.xy + 1.0f) * 0.5f * vec2(uniforms.screenSize);
	if (
		any(lessThan(prevFramePos.xy, vec2(0.0f))) ||
		any(greaterThan(prevFramePos.xy, vec2(uniforms.screenSize)))
	) {
		return;
	}

	ivec2 prevFrag = ivec2(prevFramePos.xy);

#ifdef COMPARE_DEPTH
	float depthDiff = prevFramePos.z - texelFetch(uniPrevDepth, prevFrag, 0).x;
	if (depthDiff > 0.001f * prevFramePos.z) {
		return;
	}
#else
	// highest quality results can be obtained by directly comparing the world positions
	// the performance impact of this is unclear
	vec3 positionDiff = worldPos - texelFetch(uniPrevFrameWorldPosition, prevFrag, 0).xyz;
	if (dot(positionDiff, positionDiff) > 0.01f) {
		return;
	}
#endif

	vec3 albedoDiff = albedo - texelFetch(uniPrevFrameAlbedo, prevFrag, 0).rgb;
	if (dot(albedoDiff, albedoDiff) > 0.01f) {
		return;
	}

	float normalDot = dot(normal, texelFetch(uniPrevFrameNormal, prevFrag, 0).xyz);
	if (normalDot < 0.5f) {
		return;
	}

	Rand temporalRand = seedRand(uniforms.frame * 17, reservoirIndex);
	Reservoir prevRes = prevFrameReservoirs[prevFrag.y * uniforms.screenSize.x + prevFrag.x];

	// clamp the number of samples
	prevRes.numStreamSamples = min(
		prevRes.numStreamSamples, uniforms.temporalSampleCountMultiplier * res.numStreamSamples
	);

	vec2 metallicRoughness = texelFetch(uniMaterialProperties, ivec2(pixelCoord), 0).xy;

	vec4 pHat[RESERVOIR_SIZE];
	for (int i = 0; i < RESERVOIR_SIZE; ++i) {
		pHat[i].rgb = evaluatePHat(
			worldPos, prevRes.samples[i].position.xyz, uniforms.cameraPos.xyz,
			normal, albedo, prevRes.samples[i].emission.rgb, metallicRoughness.x, metallicRoughness.y
		);
		pHat[i].w = luminance(pHat[i].r, pHat[i].g, pHat[i].b);
	}

	combineReservoirs(res, prevRes, pHat,  temporalRand);

	reservoirs[reservoirIndex] = res;
}
