#version 460 core
#extension GL_EXT_ray_tracing : enable

#include "include/disneyBRDF.glsl"
#include "include/structs/lightingPassStructs.glsl"
#include "include/structs/reservoir.glsl"

layout(location = 0) rayPayloadEXT bool isShadowed;

layout(binding = 0, set = 0) uniform accelerationStructureEXT acc;

layout(binding = 1, rgba32f) uniform image2D img;

layout (binding = 2, set = 0) uniform sampler2D uniAlbedo;
layout (binding = 3, set = 0) uniform sampler2D uniNormal;
layout (binding = 4, set = 0) uniform sampler2D uniDepth;
layout (binding = 5) uniform sampler2D uniMaterialProperties;

layout (binding = 6, set = 0) uniform Uniforms {
	LightingPassUniforms uniforms;
};

layout (binding = 7, set = 0) buffer Reservoirs {
    Reservoir reservoir;
};

float sceneDepthToWorldDepth(float depth, float near, float far) {
	return near * far / (far + depth * (near - far));
}

vec3 fragCoordDepthToViewPos(vec2 uv, float worldDepth, float tanHalfFovY, float aspectRatio) {
	uv = uv * 2.0f - 1.0f; // [0, 1] to [-1, 1]
	uv.x *= aspectRatio;
	return vec3(uv * worldDepth * tanHalfFovY, worldDepth);
}

void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    
    vec3 albedo = texture(uniAlbedo, inUV).xyz;
    vec3 normal = texture(uniNormal, inUV).xyz;
    float depth = texture(uniDepth, inUV).x;
    vec2 materialProps = texture(uniMaterialProperties, inUV).xy;

    float worldDepth = sceneDepthToWorldDepth(depth, uniforms.cameraNear, uniforms.cameraFar);
	vec3 viewPos = fragCoordDepthToViewPos(inUV, worldDepth, uniforms.tanHalfFovY, uniforms.aspectRatio);
	vec3 worldPos = (uniforms.inverseViewMatrix * vec4(viewPos, 1.0f)).xyz;

    vec4 direction = vec4(vec3(uniforms.tempLightPoint) - worldPos, 0.0f);
    
    float lightDistance = length(direction);

    direction = normalize(direction);

    vec4 origin    = vec4(worldPos, 1.0f) + 0.01 * direction;

    uint  rayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    float tMin     = 0.001;
    float tMax     = lightDistance;
    
    float hasLight = 0.0;
     for(int i = 0; i < RESERVOIR_SIZE; i++)
     {
        isShadowed = true;
       
        vec3 curLightPos = vec3(reservoir.samples[i].position);
        vec4 curDirection = vec4(vec3(curLightPos) - worldPos, 0.0f);
        float curTMax = length(curDirection);
        curDirection = normalize(curDirection);

         traceRayEXT(acc,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                0,              // sbtRecordOffset
                0,              // sbtRecordStride
                0,              // missIndex
                origin.xyz,     // ray origin
                tMin,           // ray min range
                curDirection.xyz,  // ray direction
                curTMax,           // ray max range
                0               // payload (location = 0)
        );

        if(isShadowed)
        {
            reservoir.samples[i].sumWeights = 0.0;
        }
        else
        {
            hasLight += 1.0f;
        }
     }

    isShadowed = true;

    traceRayEXT(acc,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                0,              // sbtRecordOffset
                0,              // sbtRecordStride
                0,              // missIndex
                origin.xyz,     // ray origin
                tMin,           // ray min range
                direction.xyz,  // ray direction
                tMax,           // ray max range
                0               // payload (location = 0)
    );

    float roughness = materialProps.r;
    float metallic = materialProps.g;

    if(albedo.r <= 0.04045)
        albedo.r = albedo.r / 12.92;
    else
        albedo.r = 2.4 * (albedo.r + 0.055 / 1.055);

     if(albedo.g <= 0.04045)
        albedo.g = albedo.g / 12.92;
    else
        albedo.g = 2.4 * (albedo.g + 0.055 / 1.055);

     if(albedo.b <= 0.04045)
        albedo.b = albedo.b / 12.92;
    else
        albedo.b = 2.4 * (albedo.b + 0.055 / 1.055);

    vec3 wi = uniforms.tempLightPoint.xyz - worldPos;
    float sqrDist = dot(wi, wi);
    wi /= sqrt(sqrDist);
    vec3 wo = normalize(vec3(uniforms.cameraPos) - worldPos);

    float cosIn = dot(normal, wi);
    float cosOut = dot(normal, wo);
    vec3 halfVec = normalize(wi + wo);
    float cosHalf = dot(normal, halfVec);
    float cosInHalf = dot(wi, halfVec);

    vec3 outColor =10 * disneyBrdfColor(cosIn, cosOut, cosHalf, cosInHalf, albedo, roughness, metallic) * abs(cosIn) / sqrDist;

    //outColor = albedo;

    //imageStore(img, ivec2(gl_LaunchIDEXT.xy), vec4(hasLight * vec3(1.0) / 4.0, 1.0f));

    if(isShadowed)
        imageStore(img, ivec2(gl_LaunchIDEXT.xy), vec4(0.5 * outColor, 1.0f));
    else
        imageStore(img, ivec2(gl_LaunchIDEXT.xy), vec4(outColor, 1.0f));
}
